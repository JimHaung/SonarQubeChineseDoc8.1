{"expireTime":9007200835559385000,"key":"transformer-remark-markdown-html-398fdd72bbaa543e769de4690549a786-gatsby-remark-custom-blocks-/SonarQubeChineseDoc8.1","val":"<h2>Complexity</h2>\n<p><strong>Complexity</strong> (<code>complexity</code>)<br>\nIt is the Cyclomatic Complexity calculated based on the number of paths through the code. Whenever the control flow of a function splits, the complexity counter gets incremented by one. Each function has a minimum complexity of 1. This calculation varies slightly by language because keywords and functionalities do.</p>\n<div class=\"custom-block collapse\"><div class=\"custom-block-body\"><h2>Language-specific details</h2><table>\n<thead>\n<tr>\n<th>Language</th>\n<th>Notes</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ABAP</td>\n<td>The following keywords increase the complexity by one: <code>AND</code>, <code>CATCH</code>, <code>CONTINUE</code>, <code>DO</code>, <code>ELSEIF</code>, <code>IF</code>, <code>LOOP</code>, <code>LOOPAT</code>, <code>OR</code>, <code>PROVIDE</code>, <code>SELECT…ENDSELECT</code>, <code>TRY</code>, <code>WHEN</code>, <code>WHILE</code></td>\n</tr>\n<tr>\n<td>C/C++/Objective-C</td>\n<td>The complexity gets incremented by one for: function definitions, <code>while</code>, <code>do while</code>, <code>for</code>, <code>throw</code> statements, <code>switch</code>, <code>case</code>, <code>default</code>, <code>&#x26;&#x26;</code> operator, <code>||</code> operator, <code>?</code> ternary operator, <code>catch</code>, <code>break</code>, <code>continue</code>, <code>goto</code>.</td>\n</tr>\n<tr>\n<td>COBOL</td>\n<td>The following commands increase the complexity by one (except when they are used in a copybook): <code>ALSO</code>, <code>ALTER</code>, <code>AND</code>, <code>DEPENDING</code>, <code>END_OF_PAGE</code>, <code>ENTRY</code>, <code>EOP</code>, <code>EXCEPTION</code>, <code>EXIT</code>, <code>GOBACK</code>, <code>CONTINUE</code>, <code>IF</code>, <code>INVALID</code>, <code>OR</code>, <code>OVERFLOW</code>, <code>SIZE</code>, <code>STOP</code>, <code>TIMES</code>, <code>UNTIL</code>, <code>USE</code>, <code>VARYING</code>, <code>WHEN</code>, <code>EXEC CICS HANDLE</code>, <code>EXEC CICS LINK</code>, <code>EXEC CICS XCTL</code>, <code>EXEC CICS RETURN</code></td>\n</tr>\n<tr>\n<td>Java</td>\n<td>Keywords incrementing the complexity: <code>if</code>, <code>for</code>, <code>while</code>, <code>case</code>, <code>catch</code>, <code>throw</code>, <code>&#x26;&#x26;</code>, <code>||</code>, <code>?</code></td>\n</tr>\n<tr>\n<td>JavaScript, PHP</td>\n<td>Complexity is incremented by one for each: function (i.e non-abstract and non-anonymous constructors, functions, procedures or methods), <code>if</code>, short-circuit (AKA lazy) logical conjunction (<code>&#x26;&#x26;</code>), short-circuit (AKA lazy) logical disjunction (<code>||</code>), ternary conditional expressions, loop, <code>case</code> clause of a <code>switch</code> statement, <code>throw</code> and <code>catch</code> statement, <code>go to</code> statement (only for PHP)</td>\n</tr>\n<tr>\n<td>PL/I</td>\n<td>The following keywords increase the complexity by one: <code>PROC</code>, <code>PROCEDURE</code>, <code>GOTO</code>, <code>GO TO</code>, <code>DO</code>, <code>IF</code>, <code>WHEN</code>, <code>|</code>, <code>!</code>, <code>|=</code>, <code>!=</code>, <code>&#x26;</code>, <code>&#x26;=</code></td>\n</tr>\n<tr>\n<td>PL/SQL</td>\n<td>The complexity gets incremented by one for: the main PL/SQL anonymous block (not inner ones), create procedure, create trigger, procedure<em>definition, basic loop statement, when</em>clause<em>statement (the “when” of simple</em>case<em>statement and searched</em>case<em>statement), continue</em>statement, cursor<em>for</em>loop<em>statement, continue</em>exit<em>when</em>clause (The “WHEN” part of the continue and exit statements), exception<em>handler (every individual “WHEN”), exit</em>statement, for<em>loop</em>statement, forall<em>statement, if</em>statement, elsif<em>clause, raise</em>statement, return<em>statement, while</em>loop<em>statement, and</em>expression (“and” reserved word used within PL/SQL expressions), or<em>expression (“or” reserved word used within PL/SQL expressions), when</em>clause<em>expression (the “when” of simple</em>case<em>expression and searched</em>case_expression)</td>\n</tr>\n<tr>\n<td>VB.NET</td>\n<td>The complexity gets incremented by one for: method or constructor declaration (Sub, Function), <code>AndAlso</code>, <code>Case</code>, <code>Continue</code>, <code>End</code>, <code>Error</code>, <code>Exit</code>, <code>If</code>, <code>Loop</code>, <code>On Error</code>, <code>GoTo</code>, <code>OrElse</code>, <code>Resume</code>, <code>Stop</code>, <code>Throw</code>, <code>Try</code>.</td>\n</tr>\n</tbody>\n</table></div></div>\n<p><strong>Cognitive Complexity</strong> (<code>cognitive_complexity</code>)<br>\nHow hard it is to understand the code's control flow. See <a href=\"https://www.sonarsource.com/resources/white-papers/cognitive-complexity.html\">the Cognitive Complexity White Paper</a> for a complete description of the mathematical model applied to compute this measure.</p>\n<hr>\n<h2>Duplications</h2>\n<p><strong>Duplicated blocks</strong> (<code>duplicated_blocks</code>)<br>\nNumber of duplicated blocks of lines.</p>\n<div class=\"custom-block collapse\"><div class=\"custom-block-body\"><h2>Language-specific details</h2><p>For a block of code to be considered as duplicated:</p><p>Non-Java projects:  </p><ul>\n<li>There should be at least 100 successive and duplicated tokens.</li>\n<li>Those tokens should be spread at least on:</li>\n<li>30 lines of code for COBOL</li>\n<li>20 lines of code for ABAP</li>\n<li>10 lines of code for other languages</li>\n</ul><p>Java projects:<br>\nThere should be at least 10 successive and duplicated statements whatever the number of tokens and lines. Differences in indentation and in string literals are ignored while detecting duplications.</p></div></div>\n<p><strong>Duplicated files</strong> (<code>duplicated_files</code>)<br>\nNumber of files involved in duplications.</p>\n<p><strong>Duplicated lines</strong> (<code>duplicated_lines</code>)<br>\nNumber of lines involved in duplications.</p>\n<p><strong>Duplicated lines (%)</strong> (<code>duplicated_lines_density</code>)<br>\n= <code>duplicated_lines</code> / <code>lines</code> * 100</p>\n<hr>\n<h2>Issues</h2>\n<p><strong>New issues</strong> (<code>new_violations</code>)<br>\nNumber of issues raised for the first time in the New Code period.</p>\n<p><strong>New xxx issues</strong> (<code>new_xxx_violations</code>)<br>\nNumber of issues of the specified severity raised for the first time in the New Code period, where xxx is one of: <code>blocker</code>, <code>critical</code>, <code>major</code>, <code>minor</code>, <code>info</code>.</p>\n<p><strong>Issues</strong> (<code>violations</code>)<br>\nTotal count of issues in all states.</p>\n<p><strong>xxx issues</strong> (<code>xxx_violations</code>)<br>\nTotal count of issues of the specified severity, where xxx is one of: <code>blocker</code>, <code>critical</code>, <code>major</code>, <code>minor</code>, <code>info</code>.</p>\n<p><strong>False positive issues</strong> (<code>false_positive_issues</code>)<br>\nTotal count of issues marked False Positive</p>\n<p><strong>Open issues</strong> (<code>open_issues</code>)<br>\nTotal count of issues in the Open state.</p>\n<p><strong>Confirmed issues</strong> (<code>confirmed_issues</code>)<br>\nTotal count of issues in the Confirmed state.</p>\n<p><strong>Reopened issues</strong> (<code>reopened_issues</code>)<br>\nTotal count of issues in the Reopened state</p>\n<hr>\n<h2>Maintainability</h2>\n<p><strong>Code Smells</strong> (<code>code_smells</code>)<br>\nTotal count of Code Smell issues.</p>\n<p><strong>New Code Smells</strong> (<code>new_code_smells</code>)<br>\nTotal count of Code Smell issues raised for the first time in the New Code period.</p>\n<p><strong>Maintainability Rating</strong> (<code>sqale_rating</code>)<br>\n(Formerly the SQALE rating.)\nRating given to your project related to the value of your Technical Debt Ratio. The default Maintainability Rating grid is:</p>\n<p>A=0-0.05, B=0.06-0.1, C=0.11-0.20, D=0.21-0.5, E=0.51-1</p>\n<p>The Maintainability Rating scale can be alternately stated by saying that if the outstanding remediation cost is:</p>\n<ul>\n<li>&#x3C;=5% of the time that has already gone into the application, the rating is A</li>\n<li>between 6 to 10% the rating is a B</li>\n<li>between 11 to 20% the rating is a C</li>\n<li>between 21 to 50% the rating is a D</li>\n<li>anything over 50% is an E</li>\n</ul>\n<p><strong>Technical Debt</strong> (<code>sqale_index</code>)<br>\nEffort to fix all Code Smells. The measure is stored in minutes in the database. An 8-hour day is assumed when values are shown in days.</p>\n<p><strong>Technical Debt on New Code</strong> (<code>new_technical_debt</code>)<br>\nEffort to fix all Code Smells raised for the first time in the New Code period.</p>\n<p><strong>Technical Debt Ratio</strong> (<code>sqale_debt_ratio</code>)<br>\nRatio between the cost to develop the software and the cost to fix it. The Technical Debt Ratio formula is:<br>\n<code>Remediation cost / Development cost</code><br>\nWhich can be restated as:<br>\n<code>Remediation cost / (Cost to develop 1 line of code * Number of lines of code)</code><br>\nThe value of the cost to develop a line of code is 0.06 days.</p>\n<p><strong>Technical Debt Ratio on New Code</strong> (<code>new_sqale_debt_ratio</code>)<br>\nRatio between the cost to develop the code changed in the New Code period and the cost of the issues linked to it.</p>\n<hr>\n<h2>Quality Gates</h2>\n<p><strong>Quality Gate Status</strong> (<code>alert_status</code>)<br>\nState of the Quality Gate associated to your Project. Possible values are : <code>ERROR</code>, <code>OK</code>\nWARN value has been removed since 7.6.</p>\n<p><strong>Quality Gate Details</strong> (<code>quality_gate_details</code>)<br>\nFor all the conditions of your Quality Gate, you know which condition is failing and which is not.</p>\n<hr>\n<h2>Reliability</h2>\n<p><strong>Bugs</strong> (<code>bugs</code>)<br>\nNumber of bug issues.</p>\n<p><strong>New Bugs</strong> (<code>new_bugs</code>)<br>\nNumber of new bug issues.</p>\n<p><strong>Reliability Rating</strong> (<code>reliability_rating</code>)<br>\nA = 0 Bugs<br>\nB = at least 1 Minor Bug<br>\nC = at least 1 Major Bug<br>\nD = at least 1 Critical Bug<br>\nE = at least 1 Blocker Bug  </p>\n<p><strong>Reliability remediation effort</strong> (<code>reliability_remediation_effort</code>)<br>\nEffort to fix all bug issues. The measure is stored in minutes in the DB. An 8-hour day is assumed when values are shown in days.</p>\n<p><strong>Reliability remediation effort on new code</strong> (<code>new_reliability_remediation_effort</code>)<br>\nSame as <em>Reliability remediation effort</em> but on the code changed in the New Code period.</p>\n<hr>\n<h2>Security</h2>\n<p><strong>Vulnerabilities</strong> (<code>vulnerabilities</code>)<br>\nNumber of vulnerability issues.</p>\n<p><strong>New Vulnerabilities</strong> (<code>new_vulnerabilities</code>)<br>\nNumber of new vulnerability issues.</p>\n<p><strong>Security Rating</strong> (<code>security_rating</code>)<br>\nA = 0 Vulnerabilities<br>\nB = at least 1 Minor Vulnerability<br>\nC = at least 1 Major Vulnerability<br>\nD = at least 1 Critical Vulnerability<br>\nE = at least 1 Blocker Vulnerability  </p>\n<p><strong>Security remediation effort</strong> (<code>security_remediation_effort</code>)<br>\nEffort to fix all vulnerability issues. The measure is stored in minutes in the DB. An 8-hour day is assumed when values are shown in days.</p>\n<p><strong>Security remediation effort on new code</strong> (<code>new_security_remediation_effort</code>)<br>\nSame as <em>Security remediation effort</em> but on the code changed in the New Code period.</p>\n<p><strong>Security Hotspots</strong> (<code>security_hotspots</code>)\nNumber of Security Hotspots</p>\n<p><strong>New Security Hotspots</strong> (<code>new_security_hotspots</code>)\nNumber of new Security Hotspots</p>\n<p><strong>Security Review Rating</strong> (<code>security_review_rating</code>)</p>\n<p>The ratio of the number of Security Hotspots that are in \"To Review\" status per 1K lines of code.\t</p>\n<p>A = 0–3 \"To Review\" and \"In Review\" Security Hotspots per 1K lines of code\nB = >3–10\nC = >10–15\nD = >15–25\nE = >25  </p>\n<hr>\n<h2>Size</h2>\n<p><strong>Classes</strong> (<code>classes</code>)<br>\nNumber of classes (including nested classes, interfaces, enums and annotations).</p>\n<p><strong>Comment lines</strong> (<code>comment_lines</code>)<br>\nNumber of lines containing either comment or commented-out code.</p>\n<p>Non-significant comment lines (empty comment lines, comment lines containing only special characters, etc.) do not increase the number of comment lines.</p>\n<p>The following piece of code contains 9 comment lines:</p>\n<pre><code>/**                                    +0 => empty comment line\n *                                     +0 => empty comment line\n * This is my documentation            +1 => significant comment\n * although I don't                    +1 => significant comment\n * have much                           +1 => significant comment\n * to say                              +1 => significant comment\n *                                     +0 => empty comment line\n ***************************           +0 => non-significant comment\n *                                     +0 => empty comment line\n * blabla...                           +1 => significant comment\n */                                    +0 => empty comment line\n  \n/**                                    +0 => empty comment line\n * public String foo() {               +1 => commented-out code\n *   System.out.println(message);      +1 => commented-out code\n *   return message;                   +1 => commented-out code\n * }                                   +1 => commented-out code\n */                                    +0 => empty comment line\n</code></pre>\n<div class=\"custom-block collapse\"><div class=\"custom-block-body\"><h2>Language-specific details</h2><table>\n<thead>\n<tr>\n<th>Language</th>\n<th>Note</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>COBOL</td>\n<td>Lines containing the following instructions are counted both as comments and lines of code: <code>AUTHOR</code>, <code>INSTALLATION</code>, <code>DATE-COMPILED</code>, <code>DATE-WRITTEN</code>, <code>SECURITY</code>.</td>\n</tr>\n<tr>\n<td>Java</td>\n<td>File headers are not counted as comment lines (becuase they usually define the license).</td>\n</tr>\n</tbody>\n</table></div></div>\n<p><strong>Comments (%)</strong> (<code>comment_lines_density</code>)<br>\nDensity of comment lines = Comment lines / (Lines of code + Comment lines) * 100</p>\n<p>With such a formula:</p>\n<ul>\n<li>50% means that the number of lines of code equals the number of comment lines  </li>\n<li>100% means that the file only contains comment lines  </li>\n</ul>\n<p><strong>Directories</strong> (<code>directories</code>)<br>\nNumber of directories.</p>\n<p><strong>Files</strong> (<code>files</code>)<br>\nNumber of files.</p>\n<p><strong>Lines</strong> (<code>lines</code>)<br>\nNumber of physical lines (number of carriage returns).</p>\n<p><strong>Lines of code</strong> (<code>ncloc</code>)<br>\nNumber of physical lines that contain at least one character which is neither a whitespace nor a tabulation nor part of a comment.</p>\n<div class=\"custom-block collapse\"><div class=\"custom-block-body\"><h2>Language-specific details</h2><table>\n<thead>\n<tr>\n<th>Language</th>\n<th>Note</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>COBOL</td>\n<td>Generated lines of code and pre-processing instructions (<code>SKIP1</code>, <code>SKIP2</code>, <code>SKIP3</code>, <code>COPY</code>, <code>EJECT</code>, <code>REPLACE</code>) are not counted as lines of code.</td>\n</tr>\n</tbody>\n</table></div></div>\n<p><strong>Lines of code per language</strong> (<code>ncloc_language_distribution</code>)<br>\nNon Commenting Lines of Code Distributed By Language</p>\n<p><strong>Functions</strong> (<code>functions</code>)<br>\nNumber of functions. Depending on the language, a function is either a function or a method or a paragraph.</p>\n<div class=\"custom-block collapse\"><div class=\"custom-block-body\"><h2>Language-specific details</h2><table>\n<thead>\n<tr>\n<th>Language</th>\n<th>Note</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>COBOL</td>\n<td>It is the number of paragraphs.</td>\n</tr>\n<tr>\n<td>Java</td>\n<td>Methods in anonymous classes are ignored.</td>\n</tr>\n<tr>\n<td>VB.NET</td>\n<td>Accesors are not considered to be methods.</td>\n</tr>\n</tbody>\n</table></div></div>\n<p><strong>Projects</strong> (<code>projects</code>)<br>\nNumber of projects in a Portfolio.</p>\n<p><strong>Statements</strong> (<code>statements</code>)<br>\nNumber of statements.</p>\n<hr>\n<h2>Tests</h2>\n<p><strong>Condition coverage</strong> (<code>branch_coverage</code>)<br>\nOn each line of code containing some boolean expressions, the condition coverage simply answers the following question: 'Has each boolean expression been evaluated both to true and false?'. This is the density of possible conditions in flow control structures that have been followed during unit tests execution.</p>\n<p><code>Condition coverage = (CT + CF) / (2*B)</code><br>\nwhere  </p>\n<ul>\n<li>CT = conditions that have been evaluated to 'true' at least once</li>\n<li>CF = conditions that have been evaluated to 'false' at least once</li>\n<li>B = total number of conditions</li>\n</ul>\n<p><strong>Condition coverage on new code</strong> (<code>new_branch_coverage</code>)<br>\nIdentical to Condition coverage but restricted to new / updated source code.</p>\n<p><strong>Condition coverage hits</strong> (<code>branch_coverage_hits_data</code>)<br>\nList of covered conditions.</p>\n<p><strong>Conditions by line</strong> (<code>conditions_by_line</code>)<br>\nNumber of conditions by line.</p>\n<p><strong>Covered conditions by line</strong> (<code>covered_conditions_by_line</code>)<br>\nNumber of covered conditions by line.</p>\n<p><strong>Coverage</strong> (<code>coverage</code>)<br>\nIt is a mix of Line coverage and Condition coverage. Its goal is to provide an even more accurate answer to the following question: How much of the source code has been covered by the unit tests?</p>\n<p><code>Coverage = (CT + CF + LC)/(2*B + EL)</code><br>\nwhere  </p>\n<ul>\n<li>CT = conditions that have been evaluated to 'true' at least once</li>\n<li>CF = conditions that have been evaluated to 'false' at least once</li>\n<li>LC = covered lines = lines<em>to</em>cover - uncovered_lines</li>\n<li>B = total number of conditions</li>\n<li>EL = total number of executable lines (<code>lines_to_cover</code>)</li>\n</ul>\n<p><strong>Coverage on new code</strong> (<code>new_coverage</code>)<br>\nIdentical to Coverage but restricted to new / updated source code.</p>\n<p><strong>Line coverage</strong> (<code>line_coverage</code>)<br>\nOn a given line of code, Line coverage simply answers the following question: Has this line of code been executed during the execution of the unit tests?. It is the density of covered lines by unit tests:</p>\n<p><code>Line coverage = LC / EL</code><br>\nwhere</p>\n<ul>\n<li>LC = covered lines (<code>lines_to_cover</code> - <code>uncovered_lines</code>)</li>\n<li>EL = total number of executable lines (<code>lines_to_cover</code>)</li>\n</ul>\n<p><strong>Line coverage on new code</strong> (<code>new_line_coverage</code>)<br>\nIdentical to Line coverage but restricted to new / updated source code.</p>\n<p><strong>Line coverage hits</strong> (<code>coverage_line_hits_data</code>)<br>\nList of covered lines.</p>\n<p><strong>Lines to cover</strong> (<code>lines_to_cover</code>)<br>\nNumber of lines of code which could be covered by unit tests (for example, blank lines or full comments lines are not considered as lines to cover).</p>\n<p><strong>Lines to cover on new code</strong> (<code>new_lines_to_cover</code>)<br>\nIdentical to Lines to cover but restricted to new / updated source code.</p>\n<p><strong>Skipped unit tests</strong> (<code>skipped_tests</code>)<br>\nNumber of skipped unit tests.</p>\n<p><strong>Uncovered conditions</strong> (<code>uncovered_conditions</code>)<br>\nNumber of conditions which are not covered by unit tests.</p>\n<p><strong>Uncovered conditions on new code</strong> (<code>new_uncovered_conditions</code>)<br>\nIdentical to Uncovered conditions but restricted to new / updated source code.</p>\n<p><strong>Uncovered lines</strong> (<code>uncovered_lines</code>)<br>\nNumber of lines of code which are not covered by unit tests.</p>\n<p><strong>Uncovered lines on new code</strong> (<code>new_uncovered_lines</code>)<br>\nIdentical to Uncovered lines but restricted to new / updated source code.</p>\n<p><strong>Unit tests</strong> (<code>tests</code>)<br>\nNumber of unit tests.</p>\n<p><strong>Unit tests duration</strong> (<code>test_execution_time</code>)<br>\nTime required to execute all the unit tests.</p>\n<p><strong>Unit test errors</strong> (<code>test_errors</code>)<br>\nNumber of unit tests that have failed.</p>\n<p><strong>Unit test failures</strong> (<code>test_failures</code>)<br>\nNumber of unit tests that have failed with an unexpected exception.</p>\n<p><strong>Unit test success density (%)</strong> (<code>test_success_density</code>)<br>\n<code>Test success density = (Unit tests - (Unit test errors + Unit test failures)) / Unit tests * 100</code></p>"}